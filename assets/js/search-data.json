{
  
    
        "post0": {
            "title": "\[In progress\] Data Science блог с помощью `fastpages`",
            "content": "TODO: убрать из финальной версии . &#1055;&#1083;&#1072;&#1085; &#1087;&#1088;&#1077;&#1079;&#1077;&#1085;&#1090;&#1072;&#1094;&#1080;&#1080;: . моя боль &quot;хочу блог, а удобного нет&quot;: проблемы с GitHub Pages + .ipynb; | Notion (и почему нет) + https://habr.com/ru/company/ruvds/blog/501012/ | . | fastpages: что это?; | первичная настройка блога; | плюшки; | резюме; | . | nbdev; | зачем нужен блог; | DS/ML блоги; | Полезные ссылки. | В этом посте будут пункты 2, 3 (мб), 5, 6. . В конце февраля 2020 года ребята из fast.ai представили миру fastpages - платформу для ведения блога. . Сразу скажу, что fastpages основан на Jekyll, о котором на Хабре есть множество постов. . Главное отличительная черта и приемущество fastpages состоит в поддерживаемых из коробки форматах постов: . Jupyter ноутбуки (расширение .ipynb); | Markdown файлы (расширение .md); | Word файлы (расширение .docx) | . Таким образом, автору блога необходимо сохранить пост в любом из перечисланных выше форматах в соответствующей директории: . &#39;./_notebooks/&#39; для .ipynb; | &#39;./_posts/&#39; для .md; | &#39;./_word/&#39; для .docx. | . А все остальное сделает fastpages, как утверждают его авторы. fastpages использует Github Pages для хостинга и Github Actions для автоматизации публикации постов. . Таким образом fastpages является доработкой связки Github Pages + Jekyll, где можно сразу же из Jupyter ноутбука получить опубликованный пост. . &#1055;&#1077;&#1088;&#1074;&#1080;&#1095;&#1085;&#1072;&#1103; &#1085;&#1072;&#1089;&#1090;&#1088;&#1086;&#1081;&#1082;&#1072; fastpages . Если хотите самостоятельно разобраться, то вот официальная инструкция по настройке в репозитории fastpages. . Процесс настройки fastpages: . Создать собственную копию репозитория из шаблона fastpages по ссылке | Далее автоматически откроется pull request (через ~ 30 секунд), который отвечает за настройку вашего блога, чтобы он мог начать работать. | Вам нужно выполнить иструкции из полученного pull request&#39;a и вы получите свою собственную уже работающую платформу для блога. | &#1042;&#1080;&#1076;&#1077;&#1086; &#1090;&#1091;&#1090;&#1086;&#1088;&#1080;&#1072;&#1083; &#1089; &#1087;&#1086;&#1096;&#1072;&#1075;&#1086;&#1074;&#1086;&#1081; &#1085;&#1072;&#1089;&#1090;&#1088;&#1086;&#1081;&#1082;&#1086;&#1081; . . fast_template - &#1084;&#1083;&#1072;&#1076;&#1096;&#1080;&#1081; &#1073;&#1088;&#1072;&#1090; fastpages . Стоит упомянуть, что ранее fast.ai выпустили аналогичный проект под названием fast_template, который еще проще в настройке, но не поддерживает автоматическое создание постов из Word и Jupyter файлов, а также многие другие функции перечисленные выше. Поскольку fastpages более гибок и расширяем, его авторы рекомендуют использовать его там, где это возможно. . Авторы предполагают, что fast_template может быть лучшим вариантом для тех, кто ведет не технические блоги. В этом случае посты можно создавать только с помощью встроенного онлайн-редактора Github, не заморачиваясь с использованием git. . Jupyter Notebooks &amp; Fastpages . fastpages из коробки поддерживает различные удобства. . Options via FrontMatter . Первая ячейка в вашем Jupyter ноутбуке (а также первые строки в Markdown файлах) содержит метаданные, которые могут включать/выключать опции связанные с постом. . # Title &gt; Awesome summary - toc:true- branch: master- badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . toc - при значении true автоматически будет сгенерировано оглавление поста; | badges - при значении true отображаются ссылки Google Colab и GitHub; | comments - при значении true будут включены комментарии (больше деталей); | author - при значении true отображаются имена авторов; | categories - позволяют группировать посты по тегам (на странице &quot;Tags&quot;). | . Для указания таких в Markdown файлах необходимо в начале файла задать опции как и в ноутбуке, только поместив эти метаданные между строк содержащих по три минуса, т.е. . . Выглядит это так: . toc: true layout: post description: Awesome description. categories: [markdown] title: Title . &#1057;&#1074;&#1086;&#1088;&#1072;&#1095;&#1080;&#1074;&#1072;&#1085;&#1080;&#1077;/&#1089;&#1082;&#1088;&#1099;&#1090;&#1080;&#1077; &#1082;&#1086;&#1076;&#1072; . Приятной функциональностью этого движка для блога является возможность скрывать код и/или результаты его выполнения. Это позволяет не нагружать посты отображением простыни кода или огромного количество принтов (что бывает при обучении нейросетей по эпохам), скрывая эти большие по размеру элементы, но не выкидывая их из поста на совсем. . Комментарий #hide в первой строке любой ячейки кода будет скрывать как ввод, так и вывод этой ячейки. . Ниже есть ячейка, которая не отображается в посе, но присутствует в исходном jupyter ноутбуке. Можете проверить на GitHub. . Комментарий #hide_input в первой строке любой ячейки кода будет скрывать только ввод этой ячейки. . Вы увидите только результат запуска ячейки, а именно этот комментарий. . Поместив флаг #collapse-hide, в первую строку любой ячейки, вы скроете код этой ячейки внутри поста. Но в замен появится кнопка, позволяющая показать эту ячейку. . #collapse-hide import altair as alt import pandas as pd import numpy as np . . Флаг #collapse-show позволяет показать ячейку по умолчанию, но дает читателю возможность скрыть ее. . #collapse-show np.random.seed(42) source = pd.DataFrame( np.cumsum(np.random.randn(100, 3), 0).round(2), columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;], index=pd.RangeIndex(100, name=&#39;x&#39;) ) source = source.reset_index().melt(&#39;x&#39;, var_name=&#39;category&#39;, value_name=&#39;y&#39;) . . Чтобы полностью скрыть ячейки (а не просто свернуть их), смотрите сюда. . &#1048;&#1085;&#1090;&#1077;&#1088;&#1072;&#1082;&#1090;&#1080;&#1074;&#1085;&#1099;&#1077; &#1075;&#1088;&#1072;&#1092;&#1080;&#1082;&#1080; &#1089; &#1087;&#1086;&#1084;&#1086;&#1097;&#1100;&#1102; Altair . Графики построенные с помощью библиотеки Altair внутри поста остаются интерактивными как в ноутбуке. . #collapse-hide # код отсюда: https://altair-viz.github.io/gallery/multiline_tooltip.html # Create a selection that chooses the nearest point &amp; selects based on x-value nearest = alt.selection(type=&#39;single&#39;, nearest=True, on=&#39;mouseover&#39;, fields=[&#39;x&#39;], empty=&#39;none&#39;) # The basic line line = alt.Chart(source).mark_line(interpolate=&#39;basis&#39;).encode( x=&#39;x:Q&#39;, y=&#39;y:Q&#39;, color=&#39;category:N&#39; ) # Transparent selectors across the chart. This is what tells us # the x-value of the cursor selectors = alt.Chart(source).mark_point().encode( x=&#39;x:Q&#39;, opacity=alt.value(0), ).add_selection( nearest ) # Draw points on the line, and highlight based on selection points = line.mark_point().encode( opacity=alt.condition(nearest, alt.value(1), alt.value(0)) ) # Draw text labels near the points, and highlight based on selection text = line.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=alt.condition(nearest, &#39;y:Q&#39;, alt.value(&#39; &#39;)) ) # Draw a rule at the location of the selection rules = alt.Chart(source).mark_rule(color=&#39;gray&#39;).encode( x=&#39;x:Q&#39;, ).transform_filter( nearest ) # Put the five layers into a chart and bind the data alt.layer( line, selectors, points, rules, text ).properties( width=600, height=300 ) . . &#1054;&#1090;&#1086;&#1073;&#1088;&#1072;&#1078;&#1077;&#1085;&#1080;&#1077; &#1090;&#1072;&#1073;&#1083;&#1080;&#1094; . source . x category y . 0 0 | A | 0.50 | . 1 1 | A | 2.02 | . 2 2 | A | 3.60 | . 3 3 | A | 4.14 | . 4 4 | A | 4.38 | . ... ... | ... | ... | . 295 95 | C | 5.31 | . 296 96 | C | 5.10 | . 297 97 | C | 5.95 | . 298 98 | C | 6.85 | . 299 99 | C | 7.48 | . 300 rows × 3 columns . &#1044;&#1088;&#1091;&#1075;&#1080;&#1077; &#1074;&#1086;&#1079;&#1084;&#1086;&#1078;&#1085;&#1086;&#1089;&#1090;&#1080; fastpages . &#1054;&#1090;&#1086;&#1073;&#1088;&#1072;&#1078;&#1077;&#1085;&#1080;&#1077; Emoji . Если написать Сейчас будет эмоджи :robot:., то получится . Сейчас будет эмоджи :robot:. . Шпаргалка по Emoji. . &#1042;&#1089;&#1090;&#1072;&#1074;&#1082;&#1072; &#1080;&#1079;&#1086;&#1073;&#1088;&#1072;&#1078;&#1077;&#1085;&#1080;&#1081; . Вы можете добавлять изображения с подписями следующим образом: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Напомню, что подписи опциональны, и что изображения можно указывать как локально (в рамках репозитория блога), так и находящиеся в открытом доступе (имею в виду интернет). . &#1040;&#1085;&#1080;&#1084;&#1080;&#1088;&#1086;&#1074;&#1072;&#1085;&#1085;&#1099;&#1077; &#1075;&#1080;&#1092;&#1082;&#1080; . Гифки вставляются как изображения и полноценно отображаются в постах. . . &#1055;&#1086;&#1089;&#1090;&#1099; &#1080;&#1079; &#1090;&#1074;&#1080;&#1090;&#1077;&#1088;&#1072; . Есть возможность отображать посты из твиттера. . Например, ссылка на этот пост &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 отобразит слудущее: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . &#1042;&#1080;&#1076;&#1077;&#1086; Youtube . Чтобы красиво вставить видео с Youtube достаточно использовать конструкцию: . &gt; youtube: https://youtu.be/L0boq3zqazI . Видео туториал по настройке блога прикреплен именно таким образом. . &#1055;&#1088;&#1080;&#1084;&#1077;&#1095;&#1072;&#1085;&#1080;&#1103; . Есть возможность отображать различные примечания и сноски. . Предупреждение: &gt; Warning: There will be no second warning! . Warning: There will be no second warning! . Важно: &gt; Important: Pay attention! It&#39;s important. . Important: Pay attention! It&#8217;s important. . Подсказка: &gt; Tip: This is my tip. . Tip: This is my tip. . Заметка: &gt; Note: Take note of this. . Note: Take note of this. . Если вставить в любое из примечаний ссылку, то она будет работать. Например, &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. отобразится так: . Note: A doc link to an example website: fast.ai should also work fine. . Pros &amp; Cons . Плюсы: . простота создания и размещения блога и контента; | возможность публиковать Jupyter ноутбуки в качестве постов + приятные удобства; | нет зависимости от сторонней платформы по типу Medium; | возможность разместить блог по собственному url; | комментарии для блога из коробки; | отсутствие сторонней рекламы; | . Минусы: . непонятно, как сделать структурированный блог с вложенностью - permalinks jekyll + TODO добавить ссылку на мердж реквест; структура нужна для последовательного изложения тем, а текущий блог просто сортирует посты по дате; | структура нужна для объединения нескольких постов общей темой; | хочется структуру, чтобы в одной директорий хранить данные, изображения для ноутбуков и тд в одной папке, а не искать их в куче общих для всех постов файлов и не городить какую-то структуру в этих общих для всех постов папках. | . | нет WYSIWYG (What You See Is What You Get): Jekyll его и не подразумевает из коробки; | но есть докер образ запуска блога локально; | . | Jekyll подразумевает использование git для публикации постов; | латиница в git : &quot;_posts/2020-05-26-DS 320 221 320 273 320 276 320 263 321 201 320 277 320 276 320 274 320 276 321 210 321 214 321 216 Fastpages.md&quot;; | ? складывание Jupyter ноутбуков в репо; | . &#1056;&#1077;&#1079;&#1102;&#1084;&#1077; . TODO: . DS/ML &#1073;&#1083;&#1086;&#1075;&#1080; . Анализ малых данных блог Александра Дьяконова; | Andrej Karpathy github.io, medium; | Machine Learning Mastery by Jason Brownlee; | . &#1041;&#1083;&#1086;&#1075;&#1080; &#1082;&#1086;&#1084;&#1087;&#1072;&#1085;&#1080;&#1081; . Fast.ai + fastpages blog; | Airbnb; | Uber; | OpenAI; | DeepMind; | Nvidia + AI podcast; | Microsoft AI blog + ML devblogs | . &#1055;&#1086;&#1083;&#1077;&#1079;&#1085;&#1099;&#1077; &#1089;&#1089;&#1099;&#1083;&#1082;&#1080; . Репозиторий проекта fastpages; | Introducing fastpages; | Туториал с примерами того, что можно сделать в .ipynb посте; | .",
            "url": "https://maxbalashov.github.io/ml-notes/fastpages/blogging/2020/05/26/In-progress-DS-fastpages-blog.html",
            "relUrl": "/fastpages/blogging/2020/05/26/In-progress-DS-fastpages-blog.html",
            "date": " • May 26, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Нейронные сети",
            "content": "TL; DL . Выбор функции ошибки: Кратко; | Интуитивный подход; | | Устройство нейронных сетей; | Поиск минимума функции ошибки (TODO: ссылка на градиентный спуск); | Градиентный спуск в нейросетях (Backpropagation): градиентный спуск; | вычислительные графы. | | &#1055;&#1086;&#1089;&#1090;&#1072;&#1085;&#1086;&#1074;&#1082;&#1072; &#1079;&#1072;&#1076;&#1072;&#1095;&#1080; . Главной отличительной особенностью &quot;Обучение с учиталем&quot;(Superwised learning) является наличие обучающей выборки, состоящий из пар $x_i, y_i$, где $x_i$ - признаковое представление объекта, $y_i$ - целевая переменная. В этой области машинного обучения встают задачи классификации, регрессии и тд. . Рассмотрим задачу регресии. TODO: рассписать . &#1042;&#1099;&#1073;&#1086;&#1088; &#1092;&#1091;&#1085;&#1082;&#1094;&#1080;&#1080; &#1086;&#1096;&#1080;&#1073;&#1082;&#1080; . &#1048;&#1085;&#1090;&#1091;&#1080;&#1090;&#1080;&#1074;&#1085;&#1099;&#1081; &#1087;&#1086;&#1076;&#1093;&#1086;&#1076; . Задача регрессии, если упростить, сводится к тому, чтобы модель, описывающая &quot;скрытую в данных&quot; функциональную зависимость, не ошибалась. (Не учитываем погрешность при измерениях и переобучение) Модель не ошибается, когда спрогнозированные значения совпадают с реальными (или стремятся к ним). . Как можно проверить, насколько модель ошибается? Нужно придумать подходящую функцию ошибки. Например, мы можем измерять разницу между реальным ($y_i$) и прогнозным ($ hat{y_i}$) значением для объекта из обучающей (или валидационной) выборки: . $$y_i - hat{y_i}$$ . Но измерение ошибки модели в одной контрольной точке $i$ малоинформативно, возьмем сумму ошибок по всей обучаюшей выборке ($N$ - число наблюдений в выборке): $$ sum_i^N{y_i - hat{y_i}}$$ . Вот тут мы и встречаем причину, почему просто разность в качестве функции ошибки не подходит: . Ошибки модели на разных примерах из обучающей выборки могут иметь разные знаки, компенсируя друг друга при сложении. . Пример, пусть существуют две модели A и B, которые имеют следующие ошибки $e_i = y_i - hat{y_i}$: . модель $e_1$ $e_2$ $e_3$ $e_4$ $ sum_i^N{e_i}$ . A | +3 000 | -1 000 | -1 000 | -1 000 | 0 | . B | +1 | +2 | +1 | +3 | 7 | . Получается, что: . Для модели A суммарная ошибка будет равна 0, в то время как суммарная ошибка модели B будет равна 7. . Исходя из этой логики модель A лучше, чем B. . Hо это противоречит здравому смыслу, т.к. в каждой точке модель B лучше, т.е. меньше ошибается, чем модель A. ¯ _(ツ)_/¯ . Ключевая проблема в том, что ошибки с разными знаками компенсируют друг друга. Чтобы исправить этот недостаток, можно сделать такое преобразование над ошибками, которое уберет влияние знака. . Ниже представленны примеры таких преобразований и формулы суммарной ошибки модели в результате этих преобразований:- $|x|$ (модуль числа):$$ sum_i^N{ lvert e_i rvert} = sum_i^N{ lvert y_i - hat{y_i} rvert}$$ . $x^2$ (квадрат числа): $$ sum_i^N{e_i^2} = sum_i^N{(y_i - hat{y_i})^2}$$ | . Рассмотрим уже известный пример с добавлением новых функций ошибки: . модель $e_1$ $e_2$ $e_3$ $e_4$ $ sum_i^N{e_i}$ $ sum_i^N{ lvert e_i rvert}$ $ sum_i^N{e_i^2}$ . A | +3 000 | -1 000 | -1 000 | -1 000 | 0 | 6 000 | 12 000 000 | . B | +1 | +2 | +1 | +3 | 7 | 7 | 15 | . Как можно видеть из таблицы, новые функции ошибки отражают следующий факт, что: . Модель A, которая на каждом наблюдении ошибалась сильнее, также сильнее ошибается в общем по всей выборке. . Поэтому модель A хуже, чем модель B. . Полезное свойство модуля и возведения в квадрат числа - функции ошибки теперь ограничены снизу нулем, те нуль мы получаем в случае, если модель не ошибается и всегда верно предсказывает значение целевой функции. . Напоследок, предлагаю перейти от суммарных ошибок, к усредненным по наблюдениям, т.е.:- Средняя абсолютная ошибка или MAE (Mean absolute error):$$ frac{1}{N} sum_i^N{ lvert y_i - hat{y_i} rvert}$$ . Среднеквадратичная ошибка или MSE (Mean squared error): $$ frac{1}{N} sum_i^N{(y_i - hat{y_i})^2}$$ | . Пример для наглядности: . модель $e_1$ $e_2$ $e_3$ $e_4$ $ frac{1}{N} sum_i^N{e_i}$ MAE MSE . A | +3 000 | -1 000 | -1 000 | -1 000 | 0 | 1 500 | 4 000 000 | . B | +1 | +2 | +1 | +3 | 1.75 | 1.75 | 1.75 | . Теперь функция ошибки отображает, как в среднем ошибается модель. . Также размер значения усредненной функции ошибки не зависит напрямую от количества объектов в выборке. Это удобно для сравнения полученных ошибок на обучающей, валидационной и тестовой выборках. Ведь усреднение нивелирует рост значения функции ошибки из-за увеличения числа объектов, по которым ошибка расчитывается. . &#1053;&#1077;&#1081;&#1088;&#1086;&#1089;&#1077;&#1090;&#1080; . TODO . &#1055;&#1086;&#1080;&#1089;&#1082; &#1084;&#1080;&#1085;&#1080;&#1084;&#1091;&#1084;&#1072; &#1092;&#1091;&#1085;&#1082;&#1094;&#1080;&#1080; &#1086;&#1096;&#1080;&#1073;&#1082;&#1080; . Для начала, выберем функцию ошибки для нашей модели - пусть это будет MSE: $$L( theta) = frac{1}{N} sum_i^N{(y_i - hat{y_i})^2}$$ . TODO: почему MSE??? - оптимизация через град спуск . Повторимся, в упрощенном и интуитивном понимании, для решения задачи регрессии: . Ищем такую модель, которая ошибается как можно меньше, т.е. ее ошибка стремится к минимуму. . Если выразить математически, минимизация функции ошибки выглядит так:$$L( theta) = frac{1}{N} sum_i^N{(y_i - hat{y_i})^2} rightarrow min_{ theta}$$ .",
            "url": "https://maxbalashov.github.io/ml-notes/jupyter/theory/2020/05/24/Neural-networks.html",
            "relUrl": "/jupyter/theory/2020/05/24/Neural-networks.html",
            "date": " • May 24, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Golang Notes",
            "content": ". Объявление переменных . // краткое объявление переменной (наиболее компактное) // может использоваться только внутри функции, // но не для переменных уровня пакета s := &quot;&quot; . // инициализация по умолчанию // для строки — значением &quot;&quot; var s string . // используется редко // в основном при объявлении несколь­ких переменных var s = &quot;&quot; . // содержит явное указание типа перемен­ной // является излишним, когда тип совпадает с типом начального значения переменной, // но является обязательным в других случаях, когда типы пере­менной и инициализатора разные var s string = &quot;&quot; . На практике обычно следует использовать одну из первых двух разновидностей: . с явной инициализацией (чтобы указать важность начального значения); | с неявной инициализацией по умолчанию (чтобы указать, что начальное значение не играет роли). | . Цикл for . Цикл for является единственной инструкцией цикла в Go. Он имеет ряд разно­видностей. . // Традиционный цикл `for` for инициализация; условие; последействие { // нуль или несколько инструкций } . // Традиционный цикл `while` for condition { // ... } . // Традиционный бесконечный цикл for { // ... } . Бесконечный цикл, должен завершиться некоторым иным пу­тем, например с помощью инструкции break или return. . Разновидность цикла for выполняет итерации для диапазона значений для типа данных наподобие строки или среза. . for i, arg := range someSlice { // ... } . Если мы не нуждаемся в индексе, то его можно заменить на пустой идентификатор (blank identifier) с именем _ (символ подчеркивания). Пустой идентификатор может использоваться вез­де, где синтаксис требует имя переменной, но логике программы он не нужен. . for _, arg := range someSlice { // ... } . if с краткой инструкцией . Так же как и for, оператор if может начинаться с инструкции, которая будет выполнена перед проверкой условия. . Переменные объявленные в этом блоке доступны только в области видимости, которая существует до конца if. . Переменные объявленные внутри краткой инструкции if также доступны внутри всех else блоков. . (Попробуйте использовать v в последнем операторе return.) . func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v &lt; lim { return v } else { fmt.Printf(&quot;%g &gt;= %g n&quot;, v, lim) } // can&#39;t use v here, though return lim } . switch . Вероятно вы уже догадались, на что будет похож switch. . Блок case прерывается автоматически, только если он не заканчивается оператором fallthrough. . package main import &quot;fmt&quot; func main() { // инициализируем внутри переменную `switch` // `swichCondition` существует только в рамках данного `switch` ??? switch swichCondition := 2; swichCondition { case 1: fmt.Println(&quot;Case 1&quot;) case 2: // выполнит принт согласно условию `swichCondition` fmt.Println(&quot;Case 2&quot;) // продолжит проверять последующие условия из-за `fallthrough` fallthrough default: fmt.Printf(&quot;Case default&quot;) } } . switch без условия . switch без условия это тоже самое, что и switch true. . Эта конструкция может быть использована как более ясный способ записи длинной цепочки if-then-else. . package main import ( &quot;fmt&quot; &quot;time&quot; ) func main() { t := time.Now() switch { case t.Hour() &lt; 12: fmt.Println(&quot;Good morning!&quot;) case t.Hour() &lt; 17: fmt.Println(&quot;Good afternoon.&quot;) default: fmt.Println(&quot;Good evening.&quot;) } } . Размер и вместимость среза . Срез имеет размер (длину) и вместимость. . Размер среза - это количество элементов, которые он содержит. . Вместимость среза - это количество элементов в его нижележащем массиве, начиная с первого элемента в срезе. . Размер и вместимость среза s могут быть получены с помощью len(s) и cap(s). . Размер среза может быть увеличен путем повторной операции “срезания”, при условии, что он обладает достаточной вместимостью. . Срезы по верхней границей не меняют вместимость исходного среза. Срезы по нижней границе изменяют исходный срез, уменьшая его вместимость. . import &quot;fmt&quot; func main() { s := []int{2, 3, 5, 7, 11, 13} printSlice(s) // Slice the slice to give it zero length. s = s[:0] printSlice(s) // Extend its length. s = s[:4] printSlice(s) // Вернем срез к исходному состоянию s = s[:6] printSlice(s) // Drop its first two values. // После этой операции вместимость среза `s` уменьшится. // Два первых элемента будут удалены из среза s = s[2:] printSlice(s) // Будет удален еще один элемент // Из-за среза по нижней границе s = s[1:3] printSlice(s) } func printSlice(s []int) { fmt.Printf(&quot;len=%d cap=%d %v n&quot;, len(s), cap(s), s) } . Output: len=6 cap=6 [2 3 5 7 11 13] len=0 cap=6 [] len=4 cap=6 [2 3 5 7] len=6 cap=6 [2 3 5 7 11 13] len=4 cap=4 [5 7 11 13] len=2 cap=3 [7 11] . Указатели на структуры . Доступ к полям структуры может быть получен через указатель на структуру. . Чтобы получить поле X структуры, когда у нас есть указатель на структуру p, мы можем написать: . (*p).X | p.X (без явного разыменования) | . package main import &quot;fmt&quot; type Vertex struct { X int Y int } func main() { v := Vertex{1, 2} p := &amp;v p.X = 1e9 fmt.Println(v) // {1000000000 2} } .",
            "url": "https://maxbalashov.github.io/ml-notes/markdown/programming/2020/05/24/Golang-notes.html",
            "relUrl": "/markdown/programming/2020/05/24/Golang-notes.html",
            "date": " • May 24, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://maxbalashov.github.io/ml-notes/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://maxbalashov.github.io/ml-notes/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}